<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S.O.C.O.M. // Decryption Terminal</title>
    <link rel="icon" type="image/png" href="https://www.socom.mil/SOF-ATL/PublishingImages/eSOF-Logo.png">
    <style>
        /* Base styles copied from your main project for consistency */
        @keyframes flicker { 0%, 100% { opacity: 0.95; } 50% { opacity: 1; } }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        :root {
            --bg-color: #050805; --scanline-color: rgba(0, 255, 85, 0.1); --text-color: #00ff55;
            --accent-color: #00ff55; --border-color: #00521d; --input-bg: rgba(0, 31, 9, 0.95);
            --danger-color: #ff4141; --danger-bg: rgba(255, 65, 65, 0.15); --container-bg: rgba(0,0,0,0.4);
        }

        body {
            font-family: 'Courier New', Courier, monospace; margin: 0; background-color: var(--bg-color); color: var(--text-color);
            text-shadow: 0 0 4px var(--accent-color); animation: flicker 0.15s infinite;
        }
        body::before {
            content: " "; display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-image: linear-gradient(0deg, var(--scanline-color) 1px, transparent 1px);
            background-size: 100% 2px; z-index: 100; pointer-events: none;
        }

        .container { position: relative; max-width: 1000px; margin: 10px auto; padding: 10px; border: 1px solid var(--border-color); background: var(--container-bg); }
        .header { display: flex; align-items: center; border-bottom: 1px solid var(--accent-color); padding-bottom: 5px; margin-bottom: 15px; }
        .logo { max-width: 80px; margin-right: 15px; filter: grayscale(100%) brightness(200%) contrast(150%); }

        h1 { font-size: 22px; text-transform: uppercase; }
        h1::after { content: '_'; animation: blink 1s step-end infinite; }
        h2 { font-size: 16px; margin-top: 10px; margin-bottom: 10px; text-transform: uppercase; border-bottom: 1px solid var(--border-color); padding-bottom: 4px; }
        
        .content-menu { padding: 20px; border: 1px solid var(--border-color); margin: 20px; background: var(--input-bg); }
        
        button, .button {
            background: transparent; color: var(--accent-color); border: 1px solid var(--accent-color);
            padding: 8px 15px; font-size: 14px; cursor: pointer; margin: 5px;
            font-family: 'Courier New', Courier, monospace; text-transform: uppercase;
        }
        button:hover, .button:hover { background: var(--accent-color); color: var(--bg-color); text-shadow: none; }
        button:disabled { cursor: not-allowed; opacity: 0.5; }

        input, textarea, select {
            width: 100%; padding: 6px; box-sizing: border-box; background-color: var(--input-bg); color: var(--text-color);
            border: 1px solid var(--border-color); font-family: 'Courier New', Courier, monospace;
        }
        label { font-weight: bold; display: block; margin-bottom: 4px; color: var(--accent-color); font-size: 14px; }
        
        .hidden { display: none; }
        .grid-2-col { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .status-message { padding: 10px; margin-bottom: 15px; border: 1px solid; text-align: center; }
        
        /* Minigame specific styles */
        #cipher-text-display {
            font-size: 1.2em;
            letter-spacing: 2px;
            word-break: break-all;
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border: 1px solid var(--border-color);
            min-height: 100px;
        }
        .keyword-input {
            width: 30px;
            height: 30px;
            text-align: center;
            font-size: 1.2em;
            margin: 0 2px;
            text-transform: uppercase;
        }
        .substitution-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
        }
        .sub-item { display: flex; align-items: center; gap: 5px; }
        .sub-item input { width: 30px; text-align: center; text-transform: uppercase; }
        
    </style>
</head>
<body>

    <div class="container">
        <header class="header">
            <img src="https://images.squarespace-cdn.com/content/v1/629e0596d168b365d297c6c4/cea70b06-895e-401c-9669-04fa59cfc5e6/socom-logo.png" alt="SOCOM Logo" class="logo">
            <h1>S.O.C.O.M. // DECRYPTION TERMINAL</h1>
        </header>

        <!-- GM View: For creating the encrypted message -->
        <div id="encryption-view" class="content-menu">
            <h2>NEMESIS INTERFACE // MESSAGE ENCRYPTION</h2>
            <div>
                <label for="plaintext">PLAINTEXT MESSAGE</label>
                <textarea id="plaintext" rows="5" placeholder="Enter message for encryption..."></textarea>
            </div>
            <div style="margin-top: 15px;">
                <label for="keyword">ENCRYPTION KEYWORD (A-Z, NO REPEATS)</label>
                <input type="text" id="keyword" placeholder="e.g., VALKYRIE">
            </div>
            <div style="text-align: center; margin: 15px 0;">
                <button onclick="encryptMessage()">ENCRYPT MESSAGE</button>
                <button onclick="switchToDecryptionView()">SWITCH TO AGENT VIEW</button>
            </div>
            <div>
                <label for="final-output">FINAL ENCRYPTED OUTPUT (GIVE TO AGENT)</label>
                <textarea id="final-output" rows="5" readonly></textarea>
            </div>
        </div>

        <!-- Player View: The decryption minigame -->
        <div id="decryption-view" class="content-menu hidden">
            <h2>AGENT INTERFACE // SIGNAL DECRYPTION</h2>
            
            <div id="setup-section">
                <div>
                    <label for="encrypted-input">PASTE ENCRYPTED MESSAGE</label>
                    <textarea id="encrypted-input" rows="5"></textarea>
                </div>
                <div class="grid-2-col" style="margin-top: 15px;">
                    <div>
                        <label for="sigint-skill">AGENT SIGINT SKILL %</label>
                        <input type="number" id="sigint-skill" min="0" max="100" placeholder="e.g., 55">
                    </div>
                    <div>
                        <label for="d100-roll">D100 ROLL</label>
                        <input type="number" id="d100-roll" min="1" max="100" placeholder="e.g., 23">
                    </div>
                </div>
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="startDecryption()">ATTEMPT DECRYPTION</button>
                </div>
            </div>

            <div id="minigame-section" class="hidden">
                <div id="roll-result" class="status-message"></div>
                
                <h3>CIPHERTEXT</h3>
                <div id="cipher-text-display"></div>

                <div id="puzzle-area" style="margin-top: 20px;">
                    <!-- Puzzle UI will be injected here -->
                </div>
                
                <div style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 15px; text-align:center;">
                    <button onclick="resetDecryption()">RESET TERMINAL</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        // --- State Management ---
        let decryptionData = {
            keyword: '',
            cipherMap: {},
            reversedSubstitutedText: '',
        };

        // --- View Switching ---
        function switchToDecryptionView() {
            document.getElementById('encryption-view').classList.add('hidden');
            document.getElementById('decryption-view').classList.remove('hidden');
            const encryptedMessage = document.getElementById('final-output').value;
            if (encryptedMessage) {
                document.getElementById('encrypted-input').value = encryptedMessage;
            }
        }

        // --- Encryption Logic (Multi-Step) ---
        function createCipherMap(key) {
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const uniqueKey = [...new Set(key.toUpperCase().replace(/[^A-Z]/g, ''))].join('');
            const cipherAlphabet = uniqueKey + alphabet.split('').filter(c => !uniqueKey.includes(c)).join('');
            const map = {};
            for (let i = 0; i < 26; i++) {
                map[alphabet[i]] = cipherAlphabet[i];
            }
            return map;
        }

        function applyCipher(text, map) {
            return text.toUpperCase().split('').map(char => map[char] || char).join('');
        }

        function encryptMessage() {
            const plaintext = document.getElementById('plaintext').value;
            const keyword = document.getElementById('keyword').value;

            if (!plaintext || !keyword) {
                alert('Plaintext and Keyword are required.');
                return;
            }
            
            // Step 1: Keyword Substitution Cipher
            const cipherMap = createCipherMap(keyword);
            const substitutedText = applyCipher(plaintext, cipherMap);

            // Step 2: Reverse the string
            const reversedText = substitutedText.split('').reverse().join('');

            // Step 3: Base64 Encode
            const base64Text = btoa(reversedText);

            // Bonus: Prepend keyword in Base64 for the minigame to use later, separated by a period.
            const finalPayload = btoa(keyword) + '.' + base64Text;
            
            document.getElementById('final-output').value = finalPayload;
        }

        // --- Decryption Minigame Logic ---
        function startDecryption() {
            const payload = document.getElementById('encrypted-input').value;
            const skill = parseInt(document.getElementById('sigint-skill').value);
            const roll = parseInt(document.getElementById('d100-roll').value);

            if (!payload || isNaN(skill) || isNaN(roll)) {
                alert('Please fill in the encrypted message, your SIGINT skill, and your d100 roll.');
                return;
            }
            
            try {
                // Unpack the payload
                const parts = payload.split('.');
                decryptionData.keyword = atob(parts[0]).toUpperCase();
                const base64Text = parts[1];

                // Undo encryption steps 3 and 2
                const reversedText = atob(base64Text);
                decryptionData.reversedSubstitutedText = reversedText.split('').reverse().join('');
                decryptionData.cipherMap = createCipherMap(decryptionData.keyword);

            } catch (e) {
                alert('Invalid encrypted message format. Could not decode.');
                return;
            }

            document.getElementById('setup-section').classList.add('hidden');
            document.getElementById('minigame-section').classList.remove('hidden');
            document.getElementById('cipher-text-display').textContent = decryptionData.reversedSubstitutedText;

            // Determine difficulty and set up the puzzle
            const resultEl = document.getElementById('roll-result');
            let resultText = '';
            let puzzleType = '';

            if (roll >= 96) {
                resultText = `FUMBLE (${roll}) - Catastrophic error! The decryption matrix is completely corrupted. Manual substitution required.`;
                resultEl.style.borderColor = 'var(--danger-color)';
                puzzleType = 'fumble';
            } else if (roll > skill) {
                resultText = `FAILURE (${roll}) - Signal is noisy. System could only restore common letter frequencies. Manual substitution required.`;
                resultEl.style.borderColor = 'var(--danger-color)';
                puzzleType = 'fail';
            } else if (roll <= 5) {
                resultText = `CRITICAL SUCCESS (${roll}) - Perfect signal lock! Keyword identified. Decryption is trivial.`;
                resultEl.style.borderColor = '#0f0';
                puzzleType = 'critical';
            } else { // Success
                resultText = `SUCCESS (${roll}) - Signal stabilized. System identified a keyword cipher pattern. Reconstruct the keyword.`;
                resultEl.style.borderColor = 'var(--accent-color)';
                puzzleType = 'success';
            }
            resultEl.textContent = resultText;
            setupPuzzle(puzzleType);
        }

        function setupPuzzle(type) {
            const puzzleArea = document.getElementById('puzzle-area');
            const keyword = decryptionData.keyword;
            let html = `<h3>DECRYPTION PUZZLE</h3>`;

            switch (type) {
                case 'critical':
                    html += `<p>KEYWORD IDENTIFIED: <span style="color: #0f0; font-weight: bold; letter-spacing: 2px;">${keyword}</span></p>`;
                    html += `<button onclick="solvePuzzle()">DECRYPT MESSAGE</button>`;
                    break;

                case 'success':
                    const hints = Math.floor(keyword.length / 3);
                    html += `<p>Reconstruct the ${keyword.length}-letter keyword to break the cipher.</p>`;
                    let keywordHTML = '';
                    for(let i = 0; i < keyword.length; i++) {
                        const isHint = i < hints;
                        keywordHTML += `<input type="text" class="keyword-input" maxlength="1" value="${isHint ? keyword[i] : ''}" ${isHint ? 'disabled' : ''}>`;
                    }
                    html += `<div>${keywordHTML}</div>`;
                    html += `<button style="margin-top: 10px;" onclick="checkKeywordGuess()">ATTEMPT KEYWORD</button>`;
                    break;
                
                case 'fail':
                case 'fumble':
                    html += `<p>Manually substitute each letter to decrypt the message.</p>`;
                    html += `<div class="substitution-grid">`;
                    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                    const commonLetters = ['E', 'T', 'A', 'O', 'I', 'N'];
                    for (const char of alphabet) {
                        const isHint = type === 'fail' && commonLetters.includes(decryptionData.cipherMap[char]);
                        html += `<div class="sub-item"><span>${char} = </span><input type="text" maxlength="1" id="sub-${char}" value="${isHint ? decryptionData.cipherMap[char] : ''}" ${isHint ? 'disabled' : ''} oninput="updateManualCipher()"></div>`;
                    }
                    html += `</div>`;
                    html += `<h3 style="margin-top:20px;">PLAINTEXT PREVIEW</h3><div id="manual-preview" style="background: rgba(0,0,0,0.3); padding: 15px; border: 1px solid var(--border-color); min-height: 100px;"></div>`;
                    if(type === 'fail') updateManualCipher(); // Pre-fill hints
                    break;
            }
            puzzleArea.innerHTML = html;
        }

        function checkKeywordGuess() {
            const inputs = document.querySelectorAll('.keyword-input');
            let guess = '';
            inputs.forEach(input => guess += input.value.toUpperCase());
            if (guess === decryptionData.keyword) {
                solvePuzzle();
            } else {
                alert('Incorrect keyword. Try again.');
            }
        }

        function updateManualCipher() {
            const reverseMap = {};
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (const char of alphabet) {
                const guess = document.getElementById(`sub-${char}`).value.toUpperCase();
                if (guess) {
                    reverseMap[char] = guess;
                }
            }
            const previewText = decryptionData.reversedSubstitutedText.split('').map(char => reverseMap[char] || '_').join('');
            document.getElementById('manual-preview').textContent = previewText;
        }

        function solvePuzzle() {
            const puzzleArea = document.getElementById('puzzle-area');
            // Create the reverse map from the known correct cipher map
            const reverseMap = Object.entries(decryptionData.cipherMap).reduce((acc, [key, value]) => {
                acc[value] = key;
                return acc;
            }, {});
            
            const plaintext = decryptionData.reversedSubstitutedText.split('').map(char => reverseMap[char] || char).join('');
            
            puzzleArea.innerHTML = `
                <h2 style="color: #0f0;">DECRYPTION COMPLETE</h2>
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border: 1px solid var(--border-color); font-size: 1.2em;">
                    ${plaintext}
                </div>
            `;
        }
        
        function resetDecryption() {
            document.getElementById('minigame-section').classList.add('hidden');
            document.getElementById('setup-section').classList.remove('hidden');
            document.getElementById('encrypted-input').value = '';
            document.getElementById('sigint-skill').value = '';
            document.getElementById('d100-roll').value = '';
            decryptionData = {};
        }

    </script>

</body>
</html>
