<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S.O.C.O.M. // Voiceprint Analysis</title>
    <link rel="icon" type="image/png" href="https://www.socom.mil/SOF-ATL/PublishingImages/eSOF-Logo.png">
    <style>
        /* Base styles copied from your main project */
        @keyframes flicker { 0%, 100% { opacity: 0.95; } 50% { opacity: 1; } }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        :root {
            --bg-color: #050805; --scanline-color: rgba(0, 255, 85, 0.1); --text-color: #00ff55;
            --accent-color: #00ff55; --border-color: #00521d; --input-bg: rgba(0, 31, 9, 0.95);
            --danger-color: #ff4141; --danger-bg: rgba(255, 65, 65, 0.15); --container-bg: rgba(0,0,0,0.4);
            --success-color: #0f0;
        }

        body { font-family: 'Courier New', Courier, monospace; margin: 0; background-color: var(--bg-color); color: var(--text-color); text-shadow: 0 0 4px var(--accent-color); animation: flicker 0.15s infinite; }
        .container { max-width: 1200px; margin: 10px auto; padding: 10px; border: 1px solid var(--border-color); background: var(--container-bg); }
        .header { display: flex; align-items: center; border-bottom: 1px solid var(--accent-color); padding-bottom: 5px; margin-bottom: 15px; }
        .logo { max-width: 80px; margin-right: 15px; filter: grayscale(100%) brightness(200%) contrast(150%); }
        h1 { font-size: 22px; text-transform: uppercase; } h1::after { content: '_'; animation: blink 1s step-end infinite; }
        h2 { text-transform: uppercase; border-bottom: 1px solid var(--border-color); padding-bottom: 4px; margin-top: 20px; }
        h3 { text-transform: uppercase; margin-bottom: 5px; }
        .content-menu { padding: 20px; border: 1px solid var(--border-color); margin: 20px 0; background: var(--input-bg); }
        button, .button { background: transparent; color: var(--accent-color); border: 1px solid var(--accent-color); padding: 8px 15px; font-size: 14px; cursor: pointer; margin: 5px; font-family: 'Courier New', Courier, monospace; text-transform: uppercase; text-decoration: none; }
        button:hover, .button:hover { background: var(--accent-color); color: var(--bg-color); text-shadow: none; }
        input, textarea, select { width: 100%; padding: 6px; box-sizing: border-box; background-color: var(--input-bg); color: var(--text-color); border: 1px solid var(--border-color); font-family: 'Courier New', Courier, monospace; }
        label { font-weight: bold; display: block; margin-bottom: 4px; color: var(--accent-color); font-size: 14px; }
        .hidden { display: none !important; }
        .grid-3-col { display: grid; grid-template-columns: 2fr 1fr 1fr; gap: 20px; }
        .status-message { padding: 10px; margin-bottom: 15px; border: 1px solid; text-align: center; }

        /* --- Game Specific Styles --- */
        #game-grid { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; align-items: flex-start; }
        #waveform-canvas { width: 100%; height: 150px; background: #000; border: 1px solid var(--border-color); }
        #transcript-display { background: rgba(0,0,0,0.3); border: 1px solid var(--border-color); padding: 15px; min-height: 120px; font-size: 1.2em; white-space: pre-wrap; word-break: break-all; margin-top: 15px; }
        #transcript-display.garbled { text-shadow: 0 0 8px var(--danger-color); color: rgba(255,255,255,0.4); }
        #transcript-display.success { text-shadow: 0 0 5px var(--success-color); color: var(--success-color); }
        
        #control-panel { border: 1px solid var(--border-color); padding: 15px; }
        #clarity-display { text-align: center; font-size: 1.5em; font-weight: bold; padding: 10px; border: 1px solid var(--border-color); margin-bottom: 20px; }
        .filter { margin-bottom: 15px; }

        input[type=range] { -webkit-appearance: none; width: 100%; margin: 5px 0; background: transparent; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 3px; cursor: pointer; background: var(--border-color); }
        input[type=range]::-webkit-slider-thumb { border: 1px solid var(--accent-color); height: 15px; width: 8px; background: var(--accent-color); cursor: pointer; -webkit-appearance: none; margin-top: -6px; }
    </style>
</head>
<body>

    <div class="container">
        <header class="header">
            <img src="https://images.squarespace-cdn.com/content/v1/629e0596d168b365d297c6c4/cea70b06-895e-401c-9669-04fa59cfc5e6/socom-logo.png" alt="SOCOM Logo" class="logo">
            <h1>S.O.C.O.M. // VOICEPRINT ANALYSIS</h1>
        </header>

        <!-- SETUP VIEW -->
        <div id="setup-view">
            <div class="content-menu">
                <h2>PROCEDURAL SETUP</h2>
                <div class="grid-3-col">
                    <div>
                        <label for="secret-message">SECRET MESSAGE (GM ONLY)</label>
                        <input type="text" id="secret-message" placeholder="e.g., The package is in Vienna.">
                    </div>
                    <div>
                        <label for="sigint-skill">AGENT SIGINT SKILL %</label>
                        <input type="number" id="sigint-skill" min="0" max="100" placeholder="e.g., 55">
                    </div>
                    <div>
                        <label for="d100-roll">D100 ROLL</label>
                        <input type="number" id="d100-roll" min="1" max="100" placeholder="e.g., 23">
                    </div>
                </div>
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="startAnalysis()">BEGIN ANALYSIS</button>
                </div>
            </div>
        </div>

        <!-- GAME VIEW -->
        <div id="game-view" class="hidden">
            <div id="status-display" class="status-message"></div>
            <div id="game-grid">
                <div>
                    <h3>WAVEFORM VISUALIZATION</h3>
                    <canvas id="waveform-canvas"></canvas>
                    <h3>DECRYPTED TRANSCRIPT</h3>
                    <div id="transcript-display">[ awaiting signal clarity ]</div>
                </div>
                <div id="control-panel">
                    <h3>SIGNAL CLARITY</h3>
                    <div id="clarity-display">0%</div>
                    <div id="filters-container">
                        <!-- Filters will be generated by JS -->
                    </div>
                </div>
            </div>
        </div>

        <div style="text-align: center; margin-top: 20px;">
            <a href="https://socom.vercel.app/minigames/" class="button">> RETURN TO UTILITIES MENU</a>
            <button id="reset-btn" class="hidden" onclick="window.location.reload()">RESTART SIM</button>
        </div>
    </div>

    <script>
        // --- GAME STATE & CORE LOGIC ---
        let game = {};
        const MAX_FILTER_VALUE = 1000;

        function startAnalysis() {
            const secretMessage = document.getElementById('secret-message').value;
            const skill = parseInt(document.getElementById('sigint-skill').value);
            const roll = parseInt(document.getElementById('d100-roll').value);
            if (!secretMessage || isNaN(skill) || isNaN(roll)) {
                alert('Please fill in the secret message, your SIGINT skill, and your d100 roll.');
                return;
            }

            // --- 1. INITIALIZE GAME STATE ---
            game = {
                secretMessage,
                filters: [
                    { id: 'low-pass', label: 'Low-Pass Gate', currentValue: 0, perfectValue: 0, sweetSpot: 25 },
                    { id: 'high-pass', label: 'High-Pass Gate', currentValue: 0, perfectValue: 0, sweetSpot: 25 },
                    { id: 'noise-gate', label: 'Noise Gate', currentValue: 0, perfectValue: 0, sweetSpot: 25 },
                    { id: 'band-pass', label: 'Band-Pass', currentValue: 0, perfectValue: 0, sweetSpot: 25 },
                ],
                mimicFilter: null,
                clarity: 0,
                noiseFactor: 1,
                isActive: true,
            };

            // Generate random solutions for each filter
            game.filters.forEach(f => {
                f.perfectValue = Math.floor(Math.random() * MAX_FILTER_VALUE);
                f.currentValue = Math.floor(Math.random() * MAX_FILTER_VALUE);
            });

            // --- 2. PERFORM SKILL CHECK ---
            const resultEl = document.getElementById('status-display');
            let resultText = '';
            if (roll >= 96) {
                resultText = `FUMBLE (${roll}) - Mimic frequency detected! One filter has a false sweet spot. High noise.`;
                resultEl.style.borderColor = 'var(--danger-color)';
                game.noiseFactor = 3.0;
                game.filters.forEach(f => f.sweetSpot = 5);
                // Create a mimic (false) solution for one filter
                const mimicIndex = Math.floor(Math.random() * game.filters.length);
                game.mimicFilter = { 
                    index: mimicIndex,
                    perfectValue: Math.floor(Math.random() * MAX_FILTER_VALUE),
                    sweetSpot: 30 // Make the false one easier to hit
                };
            } else if (roll > skill) {
                resultText = `FAILURE (${roll}) - Signal is heavily corrupted. Sweet spots are narrow.`;
                resultEl.style.borderColor = 'var(--danger-color)';
                game.noiseFactor = 1.8;
                game.filters.forEach(f => f.sweetSpot = 10);
            } else if (roll <= 5) {
                resultText = `CRITICAL (${roll}) - Found a clean source recording. Sweet spots are wide and one filter is pre-calibrated.`;
                resultEl.style.borderColor = 'var(--success-color)';
                game.noiseFactor = 0.5;
                game.filters.forEach(f => f.sweetSpot = 50);
                game.filters[0].currentValue = game.filters[0].perfectValue; // Pre-calibrate
            } else { // Success
                resultText = `SUCCESS (${roll}) - Standard signal quality. Operating within expected parameters.`;
                resultEl.style.borderColor = 'var(--accent-color)';
                game.noiseFactor = 1.0;
            }
            resultEl.textContent = resultText;
            
            // --- 3. RENDER UI ---
            document.getElementById('setup-view').classList.add('hidden');
            document.getElementById('game-view').classList.remove('hidden');
            document.getElementById('reset-btn').classList.remove('hidden');
            
            renderControls();
            updateAnalysis(); // Initial update
            
            // --- 4. START GAME LOOP ---
            game.animationFrame = requestAnimationFrame(updateLoop);
        }

        function renderControls() {
            const container = document.getElementById('filters-container');
            container.innerHTML = '';
            game.filters.forEach(f => {
                const el = document.createElement('div');
                el.className = 'filter';
                el.innerHTML = `
                    <label for="${f.id}">${f.label} <span id="val-${f.id}">${f.currentValue}</span></label>
                    <input type="range" id="${f.id}" min="0" max="${MAX_FILTER_VALUE}" value="${f.currentValue}" oninput="updateFilter('${f.id}')">
                `;
                container.appendChild(el);
            });
        }
        
        function updateFilter(id) {
            const f = game.filters.find(filter => filter.id === id);
            f.currentValue = parseInt(document.getElementById(id).value, 10);
            document.getElementById(`val-${id}`).textContent = f.currentValue;
            updateAnalysis();
        }

        function updateAnalysis() {
            if (!game.isActive) return;

            let totalError = 0;
            let realClarity = 0;
            let displayClarity = 0;
            
            // Calculate error based on true solutions
            game.filters.forEach(f => {
                const diff = Math.abs(f.currentValue - f.perfectValue);
                if (diff > f.sweetSpot) {
                    totalError += (diff - f.sweetSpot);
                }
            });
            realClarity = Math.max(0, 100 - (totalError / (MAX_FILTER_VALUE * game.filters.length)) * 100 * game.noiseFactor);
            
            // For Fumble, calculate a separate clarity for the mimic to trick the player
            if (game.mimicFilter) {
                let mimicError = 0;
                game.filters.forEach((f, index) => {
                    let diff;
                    if (index === game.mimicFilter.index) {
                         diff = Math.abs(f.currentValue - game.mimicFilter.perfectValue);
                         if (diff > game.mimicFilter.sweetSpot) {
                            mimicError += (diff - game.mimicFilter.sweetSpot);
                        }
                    } else {
                        diff = Math.abs(f.currentValue - f.perfectValue);
                        if (diff > f.sweetSpot) {
                            mimicError += (diff - f.sweetSpot);
                        }
                    }
                });
                const mimicClarity = Math.max(0, 100 - (mimicError / (MAX_FILTER_VALUE * game.filters.length)) * 100 * game.noiseFactor);
                // Display the higher of the two clarities, but only the real one can win
                displayClarity = Math.max(realClarity, mimicClarity);
            } else {
                displayClarity = realClarity;
            }
            
            game.clarity = displayClarity;
            document.getElementById('clarity-display').textContent = `${game.clarity.toFixed(0)}%`;
            updateTranscript(game.clarity);
            
            // Win condition is based on REAL clarity
            if (realClarity >= 95) {
                winGame();
            }
        }
        
        const GARBLED_CHARS = "#%&*@?_";
        function updateTranscript(clarity) {
            const display = document.getElementById('transcript-display');
            if (clarity >= 95) {
                display.textContent = game.secretMessage;
                display.className = 'success';
            } else {
                const clarityRatio = clarity / 100;
                let output = '';
                for(let i=0; i < game.secretMessage.length; i++) {
                    if (game.secretMessage[i] === ' ') {
                        output += ' ';
                    } else if (Math.random() < clarityRatio) {
                        output += game.secretMessage[i];
                    } else {
                        output += GARBLED_CHARS[Math.floor(Math.random() * GARBLED_CHARS.length)];
                    }
                }
                display.textContent = output;
                display.className = 'garbled';
            }
        }

        function winGame() {
            game.isActive = false;
            cancelAnimationFrame(game.animationFrame);
            // Final update to show 100% and the correct message
            document.getElementById('clarity-display').textContent = '100%';
            updateTranscript(100);
            
            const resultEl = document.getElementById('status-display');
            resultEl.textContent = "ANALYSIS COMPLETE - MESSAGE DECRYPTED";
            resultEl.style.borderColor = 'var(--success-color)';
            resultEl.style.color = 'var(--success-color)';
        }

        function updateLoop() {
            if (!game.isActive) return;
            drawWaveform();
            requestAnimationFrame(updateLoop);
        }

        function drawWaveform() {
            const canvas = document.getElementById('waveform-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const noise = (100 - game.clarity) / 100; // 0 for perfect, 1 for worst

            ctx.clearRect(0, 0, w, h);
            ctx.strokeStyle = 'var(--accent-color)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, h / 2);

            for (let x = 0; x < w; x++) {
                const sine = Math.sin(x * 0.1) * (h / 4) * (1 - noise * 0.8); // Damped sine wave
                const randomJitter = (Math.random() - 0.5) * h * noise;
                ctx.lineTo(x, h / 2 + sine + randomJitter);
            }
            ctx.stroke();
        }
        
        // --- INITIALIZE ---
        window.onload = () => {}; // Wait for user to start

    </script>
</body>
</html>
