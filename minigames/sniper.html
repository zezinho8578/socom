<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>S.O.C.O.M. // Long-Range Marksmanship</title>
<link rel="icon" type="image/png" href="https://www.socom.mil/SOF-ATL/PublishingImages/eSOF-Logo.png">
<style>
:root {
--bg-color: #050805; --text-color: #00ff55; --accent-color: #00ff55;
--border-color: #00521d; --input-bg: rgba(0, 31, 9, 0.95);
--danger-color: #ff4141; --container-bg: rgba(0,0,0,0.4);
--success-color: #0f0; --warning-color: #E8A334;
}
@keyframes flicker { 0%, 100% { opacity: 0.95; } 50% { opacity: 1; } }
@keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
body { font-family: 'Courier New', Courier, monospace; margin: 0; background-color: var(--bg-color); color: var(--text-color); text-shadow: 0 0 4px var(--accent-color); animation: flicker 0.15s infinite; }
    .container { max-width: 1200px; margin: 10px auto; padding: 10px; border: 1px solid var(--border-color); background: var(--container-bg); }
    .header { display: flex; align-items: center; border-bottom: 1px solid var(--accent-color); padding-bottom: 5px; margin-bottom: 15px; }
    .logo { max-width: 80px; margin-right: 15px; filter: grayscale(100%) brightness(200%) contrast(150%); }
    h1 { font-size: 22px; text-transform: uppercase; } h1::after { content: '_'; animation: blink 1s step-end infinite; }
    h2 { text-transform: uppercase; border-bottom: 1px solid var(--border-color); padding-bottom: 4px; margin-top: 20px; }
    .content-menu { padding: 20px; border: 1px solid var(--border-color); margin: 20px 0; background: var(--input-bg); }
    button, .button { background: transparent; color: var(--accent-color); border: 1px solid var(--accent-color); padding: 8px 15px; font-size: 14px; cursor: pointer; margin: 5px; font-family: 'Courier New', Courier, monospace; text-transform: uppercase; text-decoration: none; }
    button:hover, .button:hover { background: var(--accent-color); color: var(--bg-color); text-shadow: none; }
    input, select { width: 100%; padding: 6px; box-sizing: border-box; background-color: var(--input-bg); color: var(--text-color); border: 1px solid var(--border-color); font-family: 'Courier New', Courier, monospace; }
    label { font-weight: bold; display: block; margin-bottom: 4px; color: var(--accent-color); font-size: 14px; }
    .hidden { display: none !important; }
    .grid-7-col { display: grid; grid-template-columns: repeat(7, 1fr); gap: 20px; }
    
    #game-view { border: 1px solid var(--accent-color); position: relative; overflow: hidden; }
    #scope-canvas { display: block; width: 100%; aspect-ratio: 16/9; background-color: #111; cursor: none; }

    #hud-display {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; padding: 15px; box-sizing: border-box;
        display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: auto 1fr auto;
        gap: 10px;
    }
    .hud-item { padding: 5px; }
    .hud-top-right, .hud-bottom-right { text-align: right; }
    .hud-bottom-left { align-self: end; }
    .hud-top-left { grid-column: 1; grid-row: 1; }
    .hud-top-right { grid-column: 2; grid-row: 1; }
    .hud-bottom-left { grid-column: 1; grid-row: 3; }
    .hud-bottom-right { grid-column: 2; grid-row: 3; text-align: right; }
    .hud-label { font-size: 1em; opacity: 0.7; }
    .hud-value { font-size: 1.5em; font-weight: bold; }
    #breath-bar-container { width: 100%; max-width: 250px; height: 10px; border: 1px solid var(--accent-color); background: rgba(0,0,0,0.5); padding: 2px; }
    #breath-bar { height: 100%; background: var(--accent-color); width: 100%; transition: width 0.1s linear; }
    #heart-rate-monitor { width: 100px; height: 30px; border: 1px solid var(--border-color); background: rgba(0,0,0,0.5); }
    #dope-card-toggle { pointer-events: auto; width: fit-content; margin-left: auto; }
    #dope-card {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        width: 400px; background: var(--input-bg); border: 1px solid var(--accent-color);
        padding: 15px; box-sizing: border-box;
        font-size: 0.9em; z-index: 10;
    }
    #dope-card table { width: 100%; border-collapse: collapse; }
    #dope-card th, #dope-card td { border: 1px dotted var(--border-color); padding: 4px; text-align: center; }

    #report-view { text-align: center; }
    #report-grid { display: grid; grid-template-columns: 1fr 2fr; gap: 20px; align-items: center; }
    #body-diagram-container { position: relative; background: #333; border: 1px solid var(--border-color); padding: 10px; box-sizing: border-box; }
    #body-diagram-svg { max-width: 100%; height: auto; display: block; }
    #hit-marker {
        position: absolute; width: 15px; height: 15px; background: var(--danger-color); border-radius: 50%;
        transform: translate(-50%, -50%); box-shadow: 0 0 15px var(--danger-color);
    }
    #report-text-container { text-align: left; }
    #shot-list p { margin: 4px 0; border-bottom: 1px dotted var(--border-color); padding-bottom: 4px; cursor: help; }
    
    #shot-tooltip {
        position: fixed; display: none; background: rgba(5, 8, 5, 0.9); border: 1px solid var(--border-color);
        padding: 10px; font-size: 0.9em; pointer-events: none; z-index: 100;
    }
    
    /* NEW: Mobile Warning Overlay */
    #mobile-warning-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 200;
        padding: 15px; box-sizing: border-box;
    }
</style>
</head>
<body>

<div id="mobile-warning-overlay" class="hidden">
    <div class="content-menu" style="max-width: 500px; text-align: center;">
        <h2>SIMULATION INCOMPATIBLE</h2>
        <p style="line-height: 1.6;">This long-range marksmanship simulation requires a larger screen and the precision of a mouse for an optimal experience.</p>
        <p style="line-height: 1.6;">Please access this utility on a desktop or laptop computer.</p>
        <a href="https://socom.vercel.app/minigames/" class="button" style="margin-top: 15px;">> RETURN TO UTILITIES MENU</a>
    </div>
</div>

<div class="container">
<header class="header">
<img src="https://images.squarespace-cdn.com/content/v1/629e0596d168b365d297c6c4/cea70b06-895e-401c-9669-04fa59cfc5e6/socom-logo.png" alt="SOCOM Logo" class="logo">
<h1>S.O.C.O.M. // LONG-RANGE MARKSMANSHIP</h1>
</header>
<!-- SETUP VIEW -->
    <div id="setup-view">
        <div class="content-menu">
            <h2>ENGAGEMENT PARAMETERS</h2>
            <div class="grid-7-col">
                <div><label for="distance">RANGE (METERS)</label><input type="number" id="distance" min="100" max="1000" value="800"></div>
                <div><label for="wind-speed">WIND (KPH)</label><input type="number" id="wind-speed" min="0" max="60" value="15"></div>
                <div>
                    <label for="wind-dir">WIND DIRECTION</label>
                    <select id="wind-dir">
                       <option value="calm">CALM</option><option value="cross_lr" selected>CROSSWIND (L > R)</option><option value="cross_rl">CROSSWIND (R > L)</option><option value="headwind">HEADWIND</option><option value="tailwind">TAILWIND</option><option value="q_head_lr">QUARTERING HEADWIND (L > R)</option><option value="q_head_rl">QUARTERING HEADWIND (R > L)</option><option value="q_tail_lr">QUARTERING TAILWIND (L > R)</option><option value="q_tail_rl">QUARTERING TAILWIND (R > L)</option>
                    </select>
                </div>
                <div>
                    <label for="caliber">CALIBER</label>
                    <select id="caliber" onchange="updateMaxRange()">
                        <option value="5.56mm">5.56mm NATO</option><option value="7.62mm" selected>7.62mm NATO</option><option value=".308">.308 Winchester</option><option value="6.5mm">6.5mm Creedmoor</option><option value=".338">.338 Lapua</option><option value=".50">.50 BMG</option>
                    </select>
                </div>
                <div>
                    <label for="target-movement">TARGET MOVEMENT</label>
                    <select id="target-movement">
                        <option value="stationary">STATIONARY</option><option value="tier1">TIER I (WALK)</option><option value="tier2">TIER II (JOG)</option><option value="tier3">TIER III (VARIABLE)</option>
                    </select>
                </div>
                <div>
                    <label for="heart-rate">HEART RATE (BPM)</label>
                    <select id="heart-rate">
                        <option value="50">BELOW AVG (50)</option><option value="70" selected>AVERAGE (70)</option><option value="90">ELEVATED (90)</option>
                    </select>
                </div>
                <div><label for="shot-count">SHOTS</label><input type="number" id="shot-count" min="1" max="10" value="1"></div>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button onclick="toggleTutorial()">HOW TO PLAY</button>
                <button onclick="initGame()">BEGIN ENGAGEMENT</button>
            </div>
        </div>
        <div id="tutorial-view" class="content-menu hidden" style="margin-top: 15px; text-align: left;">
            <h2>QUICK START GUIDE</h2>
            <p>Your goal is to accurately hit the target by compensating for bullet drop, wind, and target movement.</p>
            <ul style="padding-left: 20px;">
                <li style="margin-bottom: 10px;"><strong>THE RETICLE:</strong> Your scope uses a MIL-dot reticle. Each number (1, 2, 3...) represents that many MILS from the center. The smaller hashes are half-MILS (0.5, 1.5, 2.5...). You use these markings to adjust your aim.</li>
                <li style="margin-bottom: 10px;"><strong>THE DOPE CARD:</strong> Once the engagement begins, click the [DOPE CARD] button. This is your cheat sheet for the current conditions. It gives you the correct firing solution in MILS.</li>
                <li style="margin-bottom: 10px;"><strong>ELEV (ELEVATION):</strong> This is for bullet drop. If the card says <strong>ELEV: 6.2 MILS UP</strong>, you must aim higher. Find the '6' and the first small hash below it on the vertical line of your reticle and place that point on your target.</li>
                <li style="margin-bottom: 10px;"><strong>WIND:</strong> This is for wind deflection. If the card says <strong>WIND: 2.1 MILS LEFT</strong>, the wind is pushing your bullet to the right, so you must aim 2.1 MILS to the left of the target. Use the horizontal line on your reticle.</li>
                <li style="margin-bottom: 10px;"><strong>LEAD:</strong> For moving targets. If the card says <strong>LEAD: 1.5 MILS</strong>, and the target is moving right, you must aim 1.5 MILS ahead of the target to the right.</li>
                <li style="margin-bottom: 10px;"><strong>HOLD BREATH:</strong> Press and hold the <strong>[SPACEBAR]</strong> to steady your aim. Your breath is limited, so use it wisely.</li>
            </ul>
            <div style="text-align: center;"><button onclick="toggleTutorial()">CLOSE</button></div>
        </div>
    </div>

    <!-- VIEWS -->
    <div id="game-view" class="hidden">
        <canvas id="scope-canvas"></canvas>
        <div id="hud-display">
            <div class="hud-item hud-top-left"><span class="hud-label">WIND / DIR</span><br><span class="hud-value" id="hud-wind">--</span></div>
            <div class="hud-item hud-top-right"><span class="hud-label">RANGE / CAL</span><br><span class="hud-value" id="hud-range">--</span></div>
            <div class="hud-item hud-bottom-left">
                <span class="hud-label">HOLD BREATH [SPACE]</span><br>
                <div id="breath-bar-container"><div id="breath-bar"></div></div>
                <div style="display: flex; align-items: center; margin-top: 5px;">
                    <span class="hud-label">HR:</span>
                    <canvas id="heart-rate-monitor"></canvas>
                </div>
            </div>
            <div class="hud-item hud-bottom-right">
                 <button id="dope-card-toggle" onclick="sniperGame.toggleDopeCard()">DOPE CARD</button><br>
                <span class="hud-label">STATUS</span><br><span class="hud-value" id="hud-status">STANDBY</span>
            </div>
        </div>
        <div id="dope-card" class="hidden">
            <h3 id="dope-card-header" style="text-align:center; margin:0 0 10px 0; cursor: move; user-select: none;">BALLISTICS DATA</h3>
            <p><strong>FIRING SOLUTION:</strong> ELEV: <span id="dope-elev">--</span> | WIND: <span id="dope-wind">--</span> | LEAD: <span id="dope-lead">--</span></p>
            <table><thead><tr><th>RANGE</th><th>ELEV (MILS)</th><th>WIND (MILS)</th></tr></thead><tbody id="dope-table-body"></tbody></table>
        </div>
    </div>
    <div id="report-view" class="content-menu hidden">
        <h2>AFTER ACTION REPORT</h2>
        <div id="report-grid">
            <div id="body-diagram-container">
                <svg id="body-diagram-svg" viewBox="0 0 100 250" xmlns="http://www.w3.org/2000/svg">
                    <defs><style>#body-diagram-svg .zone { fill: #ccc; stroke: #555; stroke-width: 1; }</style></defs>
                    <rect class="zone" data-zone="Head" x="38" y="0" width="24" height="25" rx="12"/>
                    <rect class="zone" data-zone="Neck" x="42" y="25" width="16" height="10"/>
                    <rect class="zone" data-zone="Upper Torso" x="25" y="35" width="50" height="15"/>
                    <rect class="zone" data-zone="Upper Torso" x="30" y="50" width="40" height="30"/>
                    <rect class="zone" data-zone="Lower Torso" x="32" y="80" width="36" height="30"/>
                    <rect class="zone" data-zone="Pelvis" x="30" y="110" width="40" height="10"/>
                    <rect class="zone" data-zone="Left Arm" x="15" y="35" width="10" height="90"/>
                    <rect class="zone" data-zone="Right Arm" x="75" y="35" width="10" height="90"/>
                    <rect class="zone" data-zone="Left Leg" x="30" y="120" width="15" height="120"/>
                    <rect class="zone" data-zone="Right Leg" x="55" y="120" width="15" height="120"/>
                </svg>
                <div id="hit-marker" class="hidden"></div>
            </div>
            <div id="report-text-container">
                <h3>SESSION ANALYSIS</h3>
                <div id="shot-list"></div>
                <h3 style="margin-top:20px;">FINAL SHOT ANALYSIS</h3>
                <p><strong>Impact Zone:</strong> <span id="report-zone">--</span></p>
                <p><strong>Chance to Survive:</strong> <span id="report-survival">--</span></p>
                <p><strong>Penetration Depth:</strong> <span id="report-depth">--</span></p>
                <p><strong>Terminal Ballistics:</strong> <span id="report-ballistics">--</span></p>
                <h3 style="margin-top:20px;">FINAL ASSESSMENT</h3><p style="font-size: 1.5em; font-weight: bold;" id="report-result">--</p>
                <h3 style="margin-top:20px;">ENGAGEMENT DATA RECAP</h3>
                <p><strong>Conditions:</strong> <span id="report-conditions">--</span></p>
            </div>
        </div>
    </div>
    <div style="text-align: center; margin-top: 20px;">
        <a href="https://socom.vercel.app/minigames/" class="button">> RETURN TO UTILITIES MENU</a>
        <button id="reset-btn" class="hidden" onclick="window.location.reload()">NEW SIMULATION</button>
    </div>
</div>

<div id="shot-tooltip"></div>

<script>
    const caliberData = {
        "5.56mm": { modifier: 1.0, maxRange: 600, muzzleVelocity: 940 },
        "7.62mm": { modifier: 1.2, maxRange: 1000, muzzleVelocity: 850 },
        ".308":   { modifier: 1.25, maxRange: 1000, muzzleVelocity: 860 },
        "6.5mm":  { modifier: 1.4, maxRange: 1200, muzzleVelocity: 880 },
        ".338":   { modifier: 2.2, maxRange: 1800, muzzleVelocity: 910 },
        ".50":    { modifier: 2.8, maxRange: 2500, muzzleVelocity: 890 }
    };

    function updateMaxRange() {
        const caliberSelect = document.getElementById('caliber');
        const distanceInput = document.getElementById('distance');
        const selectedCaliber = caliberSelect.value;
        const newMaxRange = caliberData[selectedCaliber].maxRange;

        distanceInput.max = newMaxRange;
        if (parseInt(distanceInput.value) > newMaxRange) {
            distanceInput.value = newMaxRange;
        }
    }
    
    function toggleTutorial() {
        document.getElementById('tutorial-view').classList.toggle('hidden');
    }

    document.addEventListener('DOMContentLoaded', () => {
        const MOBILE_BREAKPOINT = 768; // Common tablet portrait width

        if (window.innerWidth < MOBILE_BREAKPOINT || window.innerHeight < 600) {
            document.getElementById('mobile-warning-overlay').classList.remove('hidden');
            document.querySelector('.container').classList.add('hidden'); // Hide the main game content
        } else {
            updateMaxRange(); // Only run normal setup if on desktop
        }
    });

    class SniperGame {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId); this.ctx = this.canvas.getContext('2d');
            this.tooltip = document.getElementById('shot-tooltip');
            this.animationFrameId = null; this.isActive = false;
            this.params = {}; this.mousePos = { x: 0, y: 0 }; this.reticlePos = { x: 0, y: 0 };
            this.sway = { x: 0, y: 0, angle: Math.random() * 10 };
            this.breath = { max: 100, current: 100, isHolding: false, cooldown: 0 };
            this.shotsTaken = 0; this.shotsTotal = 1; this.impacts = []; this.shotReports = [];
            
            this.hrCanvas = document.getElementById('heart-rate-monitor');
            this.hrCtx = this.hrCanvas.getContext('2d');
            this.heartRate = { bpm: 70, interval: 0, lastBeat: 0, phase: 0, history: [] };
            this.shotTraces = [];
            this.target = { pos: { x: 0, y: 0 }, vel: { x: 0, y: 0 }, patrolLimit: 150, state: 'move', stateTimer: 0 };
            this.dopeData = [];

            this.targetSVG = new Image();
            this.targetSVG.src = `data:image/svg+xml;utf8,<svg viewBox="0 0 100 250" xmlns="http://www.w3.org/2000/svg"><g fill="%23D9453B"><rect x="38" y="0" width="24" height="25" rx="12"/><rect x="42" y="25" width="16" height="10"/><rect x="25" y="35" width="50" height="15"/><rect x="30" y="50" width="40" height="30"/><rect x="32" y="80" width="36" height="30"/><rect x="30" y="110" width="40" height="10"/><rect x="15" y="35" width="10" height="90"/><rect x="75" y="35" width="10" height="90"/><rect x="30" y="120" width="15" height="120"/><rect x="55" y="120" width="15" height="120"/></g></svg>`;

            const rootStyle = getComputedStyle(document.documentElement);
            this.colors = { accent: rootStyle.getPropertyValue('--accent-color').trim(), danger: rootStyle.getPropertyValue('--danger-color').trim(), success: rootStyle.getPropertyValue('--success-color').trim(), warning: rootStyle.getPropertyValue('--warning-color').trim() };
            this.windModels = { calm: { mult: [0, 0], name: "CALM" }, cross_lr: { mult: [1, 0], name: "CROSSWIND L > R" }, cross_rl: { mult: [-1, 0], name: "CROSSWIND R > L" }, headwind: { mult: [0, 0.5], name: "HEADWIND" }, tailwind: { mult: [0, -0.4], name: "TAILWIND" }, q_head_lr: { mult: [0.7, 0.3], name: "QUARTERING HEADWIND L>R" }, q_head_rl: { mult: [-0.7, 0.3], name: "QUARTERING HEADWIND R>L" }, q_tail_lr: { mult: [0.7, -0.2], name: "QUARTERING TAILWIND L>R" }, q_tail_rl: { mult: [-0.7, -0.2], name: "QUARTERING TAILWIND R>L" } };
            
            this.hitboxes = [
                { name: "Cranium",         rect: { x: 40, y: 2,  w: 20, h: 12 }, severity: 100 },
                { name: "Spinal Column",   rect: { x: 47, y: 28, w: 6,  h: 90 }, severity: 100 },
                { name: "Heart",           rect: { x: 44, y: 58, w: 12, h: 15 }, severity: 95 },
                { name: "Neck/Throat",     rect: { x: 43, y: 26, w: 14, h: 12 }, severity: 90 },
                { name: "Lungs",           rect: { x: 32, y: 52, w: 36, h: 26 }, severity: 70 },
                { name: "Liver",           rect: { x: 34, y: 82, w: 16, h: 13 }, severity: 65 },
                { name: "Stomach/Spleen",  rect: { x: 50, y: 82, w: 16, h: 13 }, severity: 60 },
                { name: "Pelvis",          rect: { x: 30, y: 110,w: 40, h: 10 }, severity: 55 },
                { name: "Intestines",      rect: { x: 34, y: 95, w: 32, h: 15 }, severity: 50 },
                { name: "Femoral Artery (L)", rect: { x: 35, y: 120,w: 5, h: 20 }, severity: 85 },
                { name: "Femoral Artery (R)", rect: { x: 60, y: 120,w: 5, h: 20 }, severity: 85 },
                { name: "Upper Torso",     rect: { x: 25, y: 35, w: 50, h: 45 }, severity: 40 },
                { name: "Lower Torso",     rect: { x: 32, y: 80, w: 36, h: 30 }, severity: 35 },
                { name: "Left Arm",        rect: { x: 15, y: 35, w: 10, h: 90 }, severity: 20 },
                { name: "Right Arm",       rect: { x: 75, y: 35, w: 10, h: 90 }, severity: 20 },
                { name: "Left Leg",        rect: { x: 30, y: 120,w: 15, h: 120}, severity: 25 },
                { name: "Right Leg",       rect: { x: 55, y: 120,w: 15, h: 120}, severity: 25 },
            ];
        }

        start(params) {
            this.params = params; this.isActive = true;
            this.shotsTotal = this.params.shots; this.shotsTaken = 0; this.impacts = []; this.shotReports = [];
            this.resizeCanvas(); this.setupEventListeners(); this.updateHud();
            
            const windMultiplier = (this.params.windSpeed / 3.6) * 0.2;
            const timeOfFlight = this.params.distance / caliberData[this.params.caliber].muzzleVelocity;
            this.windOffsetX = timeOfFlight * windMultiplier * this.params.windDir.mult[0] * 200;
            this.windOffsetY = timeOfFlight * windMultiplier * this.params.windDir.mult[1] * 200;
            this.dropOffset = 0.5 * 9.8 * (timeOfFlight ** 2) * 5;
            this.swayMagnitude = 5 + (this.params.distance / 200);

            this.heartRate.bpm = this.params.heartRate;
            this.heartRate.interval = 60000 / this.heartRate.bpm;
            this.heartRate.lastBeat = performance.now();

            this.target.pos = { x: this.canvas.width / 2, y: this.canvas.height / 2 };
            this.setTargetMovement(this.params.movement);

            this.generateDopeCardData();
            if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
            this.gameLoop();
        }

        setTargetMovement(tier) {
            this.target.stateTimer = Math.random() * 300 + 120;
            const baseSpeed = 0.5;
            switch (tier) {
                case 'tier1': this.target.vel = { x: baseSpeed, y: 0 }; break;
                case 'tier2': this.target.vel = { x: baseSpeed * 1.5, y: Math.random() > 0.5 ? 0.2 : -0.2 }; break;
                case 'tier3': this.target.vel = { x: baseSpeed * 2, y: 0 }; this.target.state = 'stop'; break;
                case 'stationary': default: this.target.vel = { x: 0, y: 0 }; break;
            }
        }

        generateDopeCardData() {
            this.dopeData = [];
            const maxRange = caliberData[this.params.caliber].maxRange;
            for (let range = 100; range <= maxRange; range += 100) {
                const tof = range / caliberData[this.params.caliber].muzzleVelocity;
                const dropMeters = 0.5 * 9.8 * (tof ** 2);
                const dropMils = (dropMeters / range) * 1000;
                
                const windDriftMeters = ((this.params.windSpeed / 3.6) * 0.2) * tof;
                const windMils = (windDriftMeters / range) * 1000;
                
                this.dopeData.push({ range, elev: dropMils.toFixed(1), wind: windMils.toFixed(1) });
            }
            this.updateDopeCardDisplay();
        }

        updateDopeCardDisplay() {
            const tableBody = document.getElementById('dope-table-body');
            tableBody.innerHTML = this.dopeData.map(d => `<tr><td>${d.range}m</td><td>${d.elev}</td><td>${d.wind}</td></tr>`).join('');
            
            const pixelsPerMil = 40;
            const dropMils = this.dropOffset / pixelsPerMil;
            const windMils = this.windOffsetX / pixelsPerMil;
            
            const targetSpeedPixelsPerFrame = Math.sqrt(this.target.vel.x ** 2 + this.target.vel.y ** 2);
            const timeOfFlight = this.params.distance / caliberData[this.params.caliber].muzzleVelocity;
            const leadPixels = targetSpeedPixelsPerFrame * timeOfFlight * 60;
            const leadMils = leadPixels / pixelsPerMil;

            document.getElementById('dope-elev').textContent = `${dropMils.toFixed(1)} MILS UP`;
            document.getElementById('dope-wind').textContent = `${Math.abs(windMils).toFixed(1)} MILS ${windMils > 0 ? 'LEFT' : 'RIGHT'}`;
            document.getElementById('dope-lead').textContent = this.params.movement === 'stationary' ? 'N/A' : `${Math.abs(leadMils).toFixed(1)} MILS`;
        }

        toggleDopeCard = () => {
            const card = document.getElementById('dope-card');
            card.classList.toggle('hidden');
            if (!card.classList.contains('hidden')) {
                card.style.left = '50%';
                card.style.top = '50%';
                card.style.transform = 'translate(-50%, -50%)';
            }
        }

        gameLoop = () => { if (!this.isActive) return; this.update(); this.draw(); this.animationFrameId = requestAnimationFrame(this.gameLoop); }

        update() {
            if (this.breath.isHolding) { this.breath.current = Math.max(0, this.breath.current - 0.11); if (this.breath.current === 0) { this.breath.isHolding = false; this.breath.cooldown = 100; } } else { this.breath.current = Math.min(this.breath.max, this.breath.current + 0.5); this.breath.cooldown = Math.max(0, this.breath.cooldown - 1); }
            document.getElementById('breath-bar').style.width = `${this.breath.current}%`;
            
            const now = performance.now();
            const timeSinceBeat = now - this.heartRate.lastBeat;
            if (timeSinceBeat < this.heartRate.interval) {
                this.heartRate.phase = timeSinceBeat / this.heartRate.interval;
            } else {
                this.heartRate.lastBeat = now;
                this.heartRate.phase = 0;
            }
            this.drawHeartRate();

            let currentSway = this.swayMagnitude;
            if (this.breath.isHolding) currentSway *= 0.1; if (this.breath.cooldown > 0) currentSway *= 3;
            this.sway.angle += 0.02; 
            this.sway.x = Math.cos(this.sway.angle) * currentSway;
            this.sway.y = Math.sin(this.sway.angle * 2) * currentSway * 0.7;
            this.reticlePos.x = this.mousePos.x + this.sway.x; this.reticlePos.y = this.mousePos.y + this.sway.y;

            if (this.params.movement !== 'stationary') {
                this.target.pos.x += this.target.vel.x; this.target.pos.y += this.target.vel.y;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const verticalPatrolLimit = 50;
                
                if (this.target.pos.x > centerX + this.target.patrolLimit || this.target.pos.x < centerX - this.target.patrolLimit) {
                    this.target.vel.x *= -1;
                }
                if (this.target.pos.y > centerY + verticalPatrolLimit || this.target.pos.y < centerY - verticalPatrolLimit) {
                    this.target.vel.y *= -1;
                }
                
                if (this.params.movement === 'tier3') {
                    this.target.stateTimer--;
                    if (this.target.stateTimer <= 0) {
                        this.target.state = this.target.state === 'move' ? 'stop' : 'move';
                        this.target.vel.x = this.target.state === 'move' ? (Math.random() > 0.5 ? 0.8 : -0.8) * 2 : 0;
                        this.target.stateTimer = Math.random() * 200 + 100;
                    }
                }
            }

            this.shotTraces = this.shotTraces.filter(t => { t.life--; return t.life > 0; });
        }

        calculateEKG(phase) {
            const p = 0.5 * Math.exp(-150 * (phase - 0.15)**2);
            const q = -0.4 * Math.exp(-250 * (phase - 0.25)**2);
            const r = 4.0 * Math.exp(-400 * (phase - 0.3)**2);
            const s = -1.0 * Math.exp(-300 * (phase - 0.35)**2);
            const t = 0.8 * Math.exp(-60 * (phase - 0.55)**2);
            return p + q + r + s + t;
        }

        draw() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.save();
            this.drawTarget(); 
            this.impacts.forEach(this.drawImpactMarker);
            this.shotTraces.forEach(this.drawShotTrace);
            this.ctx.restore();
            this.drawScopeOverlay(); this.drawReticle();
        }

        drawTarget() {
            const scale = Math.max(0.1, 200 / this.params.distance);
            const w = 100 * scale; const h = 250 * scale;
            this.ctx.drawImage(this.targetSVG, this.target.pos.x - w / 2, this.target.pos.y - h / 2, w, h);
        }

        drawImpactMarker = (impact) => {
            this.ctx.strokeStyle = this.colors.danger; this.ctx.lineWidth = 2;
            const size = 10; this.ctx.beginPath();
            this.ctx.moveTo(impact.x - size, impact.y - size); this.ctx.lineTo(impact.x + size, impact.y + size);
            this.ctx.moveTo(impact.x + size, impact.y - size); this.ctx.lineTo(impact.x - size, impact.y + size);
            this.ctx.stroke();
        }
        
        drawShotTrace = (trace) => {
            this.ctx.beginPath();
            this.ctx.moveTo(this.canvas.width / 2, this.canvas.height / 2);
            this.ctx.quadraticCurveTo(trace.midX, trace.midY, trace.endX, trace.endY);
            this.ctx.strokeStyle = `rgba(255, 230, 150, ${trace.life / 90})`;
            this.ctx.lineWidth = 2;
            this.ctx.stroke();
        }

        drawReticle() {
            const x = this.reticlePos.x; const y = this.reticlePos.y;
            const milSize = 40; 
            this.ctx.strokeStyle = this.colors.accent; this.ctx.lineWidth = 1; this.ctx.fillStyle = this.colors.accent;
            this.ctx.font = '10px Courier New'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
            
            this.ctx.beginPath();
            this.ctx.moveTo(x - milSize * 5.5, y); this.ctx.lineTo(x + milSize * 5.5, y);
            this.ctx.moveTo(x, y - milSize * 5.5); this.ctx.lineTo(x, y + milSize * 5.5);
            this.ctx.stroke();

            for (let i = 0.5; i <= 5; i += 0.5) {
                const isFullMil = i % 1 === 0;
                const hashSize = isFullMil ? 6 : 3;

                this.ctx.beginPath();
                this.ctx.moveTo(x - milSize * i, y - hashSize); this.ctx.lineTo(x - milSize * i, y + hashSize);
                this.ctx.moveTo(x + milSize * i, y - hashSize); this.ctx.lineTo(x + milSize * i, y + hashSize);
                this.ctx.moveTo(x - hashSize, y - milSize * i); this.ctx.lineTo(x + hashSize, y - milSize * i);
                this.ctx.moveTo(x - hashSize, y + milSize * i); this.ctx.lineTo(x + hashSize, y + milSize * i);
                this.ctx.stroke();

                if (isFullMil) {
                    this.ctx.fillText(i, x + 12, y + milSize * i);
                    this.ctx.fillText(i, x + 12, y - milSize * i);
                    this.ctx.fillText(i, x + milSize * i, y + 12);
                    this.ctx.fillText(i, x - milSize * i, y + 12);
                }
            }
        }
        
        drawScopeOverlay() {
            this.ctx.fillStyle = 'black'; this.ctx.beginPath();
            const centerX = this.canvas.width / 2; const centerY = this.canvas.height / 2;
            const radius = Math.min(centerX, centerY) * 1.2;
            this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI); this.ctx.rect(this.canvas.width, 0, -this.canvas.width, this.canvas.height);
            this.ctx.fill();
        }

        drawHeartRate() {
            const currentPulse = this.calculateEKG(this.heartRate.phase);
            this.heartRate.history.push(currentPulse);
            if (this.heartRate.history.length > this.hrCanvas.width) { this.heartRate.history.shift(); }
            this.hrCtx.clearRect(0, 0, this.hrCanvas.width, this.hrCanvas.height);
            this.hrCtx.beginPath();
            this.hrCtx.strokeStyle = this.colors.accent;
            this.hrCtx.lineWidth = 1.5;
            const h = this.hrCanvas.height;
            this.hrCtx.moveTo(0, h / 1.5);
            this.heartRate.history.forEach((val, i) => { this.hrCtx.lineTo(i, (h / 1.5) - (val * 2)); });
            this.hrCtx.stroke();
        }

        fireShot() {
            if (this.shotsTaken >= this.shotsTotal) return;
            this.shotsTaken++;
            
            const timeOfFlight = this.params.distance / caliberData[this.params.caliber].muzzleVelocity;
            const predictedTargetPos = {
                x: this.target.pos.x + this.target.vel.x * timeOfFlight * 60,
                y: this.target.pos.y + this.target.vel.y * timeOfFlight * 60
            };
            
            const correctAimPoint = { 
                x: predictedTargetPos.x - this.windOffsetX, 
                y: predictedTargetPos.y - this.dropOffset + this.windOffsetY 
            };
            
            const errorX = this.reticlePos.x - correctAimPoint.x;
            const errorY = this.reticlePos.y - correctAimPoint.y;
            const impact = { x: predictedTargetPos.x + errorX, y: predictedTargetPos.y + errorY };
            this.impacts.push(impact);
            
            this.shotTraces.push({
                endX: impact.x, endY: impact.y,
                midX: (this.canvas.width/2 + impact.x)/2, midY: (this.canvas.height/2 + impact.y)/2 - this.dropOffset/2,
                life: 90
            });

            const scale = Math.max(0.1, 200 / this.params.distance);
            const w = 100 * scale; const h = 250 * scale;
            const targetLeft = this.target.pos.x - w / 2; const targetTop = this.target.pos.y - h / 2;

            let reportDetails;
            if (impact.x >= targetLeft && impact.x <= targetLeft + w && impact.y >= targetTop && impact.y <= targetTop + h) {
                const localX = impact.x - targetLeft; const localY = impact.y - targetTop;
                reportDetails = { isHit: true, localPercentX: localX / w, localPercentY: localY / h, impactX: impact.x };
            } else {
                reportDetails = { isHit: false, impactX: impact.x };
            }
            this.shotReports.push(this.analyzeHit(reportDetails));
            this.updateHud();

            if (this.shotsTaken >= this.shotsTotal) {
                this.isActive = false;
                setTimeout(() => this.generateReport(), 1000);
            }
        }
        
        analyzeHit(details) {
            let zone = "Miss", result = "TARGET UNHARMED", depth = 0, survivalChance = "N/A", survivedRoll = true;
            if (details.isHit) {
                const hitX = details.localPercentX * 100;
                const hitY = details.localPercentY * 250;
                const caliberMod = caliberData[this.params.caliber].modifier;
                let hitDetected = false;
                for (const hitbox of this.hitboxes) {
                    const r = hitbox.rect;
                    if (hitX >= r.x && hitX <= r.x + r.w && hitY >= r.y && hitY <= r.y + r.h) {
                        zone = hitbox.name;
                        const finalTrauma = hitbox.severity * caliberMod;
                        survivalChance = Math.max(0, 100 - finalTrauma);
                        const roll = Math.random() * 100;
                        survivedRoll = roll < survivalChance;
                        if (!survivedRoll) { result = "TARGET NEUTRALIZED"; }
                        else {
                            if (finalTrauma > 80) result = "TARGET CRITICALLY WOUNDED";
                            else if (finalTrauma > 50) result = "TARGET SIGNIFICANTLY WOUNDED";
                            else result = "TARGET WOUNDED";
                        }
                        hitDetected = true;
                        break;
                    }
                }
                if (!hitDetected) { zone = "Flesh Wound"; result = "TARGET WOUNDED"; survivalChance = 95.0; }
                const caliberPenetration = { "5.56mm": 80, "7.62mm": 120, ".308": 125, "6.5mm": 140, ".338": 180, ".50": 300 };
                depth = caliberPenetration[this.params.caliber] + Math.random() * 20 - 10;
            }
            const horizontalDev = details.impactX - (this.target.pos.x);
            return { zone, result, depth, horizontalDev, details, survivalChance, survivedRoll };
        }

        generateReport() {
            document.getElementById('game-view').classList.add('hidden');
            document.getElementById('report-view').classList.remove('hidden');
            const shotListContainer = document.getElementById('shot-list');
            shotListContainer.innerHTML = '';
            this.shotReports.forEach((shot, index) => {
                const p = document.createElement('p');
                p.innerHTML = `SHOT ${index + 1}: <strong style="color: ${shot.result === 'TARGET NEUTRALIZED' ? this.colors.success : (shot.zone === 'Miss' ? this.colors.danger : this.colors.warning)}">${shot.zone} - [${shot.result}]</strong>`;
                p.addEventListener('mousemove', (e) => this.showTooltip(index, e));
                p.addEventListener('mouseout', () => this.hideTooltip());
                shotListContainer.appendChild(p);
            });
            const finalShot = this.shotReports[this.shotReports.length - 1];
            document.getElementById('report-zone').textContent = finalShot.zone;
            document.getElementById('report-survival').textContent = typeof finalShot.survivalChance === 'number' ? `${finalShot.survivalChance.toFixed(1)}%` : "N/A";
            document.getElementById('report-depth').textContent = finalShot.details.isHit ? `${finalShot.depth.toFixed(1)} mm` : "N/A";
            document.getElementById('report-ballistics').textContent = `Projectile: ${this.params.caliber}. Impact vector shows ${Math.abs(finalShot.horizontalDev).toFixed(2)}px horizontal deviation.`;
            document.getElementById('report-conditions').textContent = `${this.params.distance}m | ${this.params.windSpeed} KPH ${this.params.windDir.name} | ${this.params.caliber}`;
            let finalAssessment = "TARGET MISSED";
            if (this.shotReports.some(s => !s.survivedRoll)) { finalAssessment = "TARGET NEUTRALIZED"; }
            else {
                const woundLevels = this.shotReports.map(s => s.result);
                if (woundLevels.includes("TARGET CRITICALLY WOUNDED")) finalAssessment = "TARGET CRITICALLY WOUNDED";
                else if (woundLevels.includes("TARGET SIGNIFICANTLY WOUNDED")) finalAssessment = "TARGET SIGNIFICANTLY WOUNDED";
                else if (woundLevels.includes("TARGET WOUNDED")) finalAssessment = "TARGET WOUNDED";
            }
            document.getElementById('report-result').textContent = finalAssessment;
            document.getElementById('report-result').style.color = finalAssessment === "TARGET NEUTRALIZED" ? this.colors.success : (finalAssessment === 'TARGET MISSED' ? this.colors.danger : this.colors.warning);
            if (finalShot.details.isHit) {
                const hitMarker = document.getElementById('hit-marker');
                const markerX = finalShot.details.localPercentX * 100;
                const markerY = finalShot.details.localPercentY * 100;
                hitMarker.style.left = `${markerX}%`; hitMarker.style.top = `${markerY}%`;
                hitMarker.classList.remove('hidden');
            }
        }
        
        showTooltip = (index, event) => {
            const shot = this.shotReports[index];
            let content = `<strong>Zone:</strong> ${shot.zone}<br>`;
            content += `<strong>Survival Chance:</strong> ${typeof shot.survivalChance === 'number' ? shot.survivalChance.toFixed(1) + '%' : 'N/A'}<br>`;
            content += `<strong>Result:</strong> ${shot.survivedRoll ? 'Survived' : 'Neutralized'}<br>`;
            content += `<strong>Depth:</strong> ${shot.details.isHit ? shot.depth.toFixed(1) + ' mm' : 'N/A'}<br>`;
            this.tooltip.innerHTML = content;
            this.tooltip.style.display = 'block';
            this.tooltip.style.left = `${event.clientX + 15}px`;
            this.tooltip.style.top = `${event.clientY}px`;
        }

        hideTooltip = () => { this.tooltip.style.display = 'none'; }

        setupEventListeners() {
            this.canvas.oncontextmenu = (e) => e.preventDefault();
            this.canvas.onmousemove = (e) => { const rect = this.canvas.getBoundingClientRect(); this.mousePos.x = e.clientX - rect.left; this.mousePos.y = e.clientY - rect.top; };
            this.canvas.onmousedown = (e) => { if (e.button === 0) this.fireShot(); };
            document.onkeydown = (e) => { if (e.code === 'Space') { e.preventDefault(); if(!this.breath.cooldown) this.breath.isHolding = true; } };
            document.onkeyup = (e) => { if (e.code === 'Space') this.breath.isHolding = false; };
            window.onresize = this.resizeCanvas;
        }
        
        resizeCanvas = () => { 
            const container = document.getElementById('game-view'); 
            this.canvas.width = container.clientWidth; 
            this.canvas.height = container.clientWidth * (9 / 16); 
            this.hrCanvas.width = 100;
            this.hrCanvas.height = 30;
        }

        updateHud() {
            document.getElementById('hud-wind').textContent = `${this.params.windSpeed} KPH ${this.params.windDir.name}`;
            document.getElementById('hud-range').textContent = `${this.params.distance}m / ${this.params.caliber}`;
            document.getElementById('hud-status').textContent = `SHOT ${this.shotsTaken} / ${this.shotsTotal}`;
        }
    }
    
    let sniperGame = new SniperGame('scope-canvas');
    function initGame() {
        document.getElementById('setup-view').classList.add('hidden');
        document.getElementById('game-view').classList.remove('hidden');
        document.getElementById('reset-btn').classList.remove('hidden');
        sniperGame.start({ 
            distance: parseInt(document.getElementById('distance').value), 
            windSpeed: parseInt(document.getElementById('wind-speed').value), 
            windDir: sniperGame.windModels[document.getElementById('wind-dir').value], 
            caliber: document.getElementById('caliber').value,
            shots: parseInt(document.getElementById('shot-count').value),
            movement: document.getElementById('target-movement').value,
            heartRate: parseInt(document.getElementById('heart-rate').value)
        });
    }

    const dopeCard = document.getElementById('dope-card');
    const dopeCardHeader = document.getElementById('dope-card-header');
    let isDragging = false;
    let offsetX, offsetY;
    dopeCardHeader.addEventListener('mousedown', (e) => {
        e.preventDefault(); isDragging = true;
        const rect = dopeCard.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        dopeCard.style.transform = 'none';
        dopeCard.style.left = `${rect.left}px`;
        dopeCard.style.top = `${rect.top}px`;
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    });
    function onMouseMove(e) { if (!isDragging) return; dopeCard.style.left = `${e.clientX - offsetX}px`; dopeCard.style.top = `${e.clientY - offsetY}px`; }
    function onMouseUp() { isDragging = false; document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); }
</script>
</body>
</html>
